<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reminders Vault Test Suite</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 1rem;
            color: #333;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .test-header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .test-header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .test-header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .test-controls {
            padding: 1.5rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-success {
            background: #10b981;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-danger {
            background: #ef4444;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .test-summary {
            padding: 1.5rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            background: #f8f9fa;
        }

        .summary-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .summary-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .summary-number.passed { color: #10b981; }
        .summary-number.failed { color: #ef4444; }
        .summary-number.total { color: #3b82f6; }
        .summary-number.coverage { color: #f59e0b; }

        .test-results {
            padding: 1.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .test-suite {
            margin-bottom: 2rem;
        }

        .suite-header {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .suite-header:hover {
            background: #e2e8f0;
        }

        .suite-title {
            font-weight: 600;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .suite-stats {
            font-size: 0.9rem;
            color: #6b7280;
        }

        .test-list {
            margin-left: 1rem;
        }

        .test-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .test-item.passed {
            background: #f0fdf4;
            border-left: 4px solid #10b981;
        }

        .test-item.failed {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
        }

        .test-item.running {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .test-name {
            font-weight: 500;
        }

        .test-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .status-icon {
            font-size: 1.2rem;
        }

        .test-duration {
            color: #6b7280;
            font-size: 0.8rem;
        }

        .test-error {
            margin-top: 0.5rem;
            padding: 0.75rem;
            background: #fee2e2;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
            color: #991b1b;
            max-height: 150px;
            overflow-y: auto;
        }

        .console-output {
            background: #1f2937;
            color: #f9fafb;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #3b82f6);
            transition: width 0.3s ease;
            width: 0%;
        }

        .hidden {
            display: none;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .collapsible {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible.expanded {
            max-height: 1000px;
        }

        @media (max-width: 768px) {
            .test-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                justify-content: center;
            }

            .test-summary {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
<div class="test-container">
    <!-- Header -->
    <div class="test-header">
        <h1>üß™ Reminders Vault Test Suite</h1>
        <p>Comprehensive testing for storage, services, and user workflows</p>
    </div>

    <!-- Controls -->
    <div class="test-controls">
        <button class="btn" id="runAllTests">
            <span>üöÄ</span>
            Run All Tests
        </button>
        <button class="btn btn-secondary" id="runUnitTests">
            <span>‚ö°</span>
            Unit Tests Only
        </button>
        <button class="btn btn-secondary" id="runIntegrationTests">
            <span>üîó</span>
            Integration Tests
        </button>
        <button class="btn btn-success" id="runStorageTests">
            <span>üíæ</span>
            Storage Tests
        </button>
        <button class="btn btn-danger" id="clearResults">
            <span>üóëÔ∏è</span>
            Clear Results
        </button>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <!-- Summary -->
    <div class="test-summary" id="testSummary">
        <div class="summary-card">
            <div class="summary-number total" id="totalTests">0</div>
            <div>Total Tests</div>
        </div>
        <div class="summary-card">
            <div class="summary-number passed" id="passedTests">0</div>
            <div>Passed</div>
        </div>
        <div class="summary-card">
            <div class="summary-number failed" id="failedTests">0</div>
            <div>Failed</div>
        </div>
        <div class="summary-card">
            <div class="summary-number coverage" id="coverage">0%</div>
            <div>Coverage</div>
        </div>
    </div>

    <!-- Results -->
    <div class="test-results" id="testResults">
        <!-- Test suites will be populated here -->
    </div>

    <!-- Console Output -->
    <div class="console-output" id="consoleOutput" style="display: none;">
        <div id="consoleText"></div>
    </div>
</div>

<!-- Test Framework and Implementation -->
<script type="module">
    // Simple Test Framework
    class TestFramework {
        constructor() {
            this.suites = new Map();
            this.results = {
                total: 0,
                passed: 0,
                failed: 0,
                running: false
            };
            this.console = [];
        }

        suite(name, tests) {
            this.suites.set(name, {
                name,
                tests: tests || [],
                results: { total: 0, passed: 0, failed: 0 }
            });
        }

        test(suiteName, testName, testFn) {
            if (!this.suites.has(suiteName)) {
                this.suite(suiteName);
            }

            const suite = this.suites.get(suiteName);
            suite.tests.push({
                name: testName,
                fn: testFn,
                status: 'pending',
                duration: 0,
                error: null
            });
        }

        async runAll(filter = null) {
            this.results = { total: 0, passed: 0, failed: 0, running: true };
            this.console = [];

            this.updateUI();

            for (const [suiteName, suite] of this.suites) {
                if (filter && !suiteName.toLowerCase().includes(filter.toLowerCase())) {
                    continue;
                }

                await this.runSuite(suite);
            }

            this.results.running = false;
            this.updateUI();
            this.showResults();
        }

        async runSuite(suite) {
            suite.results = { total: 0, passed: 0, failed: 0 };

            for (const test of suite.tests) {
                await this.runTest(suite, test);
            }
        }

        async runTest(suite, test) {
            test.status = 'running';
            this.updateTestUI(suite.name, test);

            const startTime = performance.now();

            try {
                // Run test with timeout
                await Promise.race([
                    test.fn(),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Test timeout (5s)')), 5000)
                    )
                ]);

                test.status = 'passed';
                test.error = null;
                suite.results.passed++;
                this.results.passed++;
            } catch (error) {
                test.status = 'failed';
                test.error = error.message || error.toString();
                suite.results.failed++;
                this.results.failed++;

                this.log(`‚ùå ${suite.name} > ${test.name}: ${test.error}`);
            }

            test.duration = performance.now() - startTime;
            suite.results.total++;
            this.results.total++;

            this.updateTestUI(suite.name, test);
            this.updateProgress();
        }

        updateProgress() {
            const totalTests = Array.from(this.suites.values())
                .reduce((sum, suite) => sum + suite.tests.length, 0);

            const progress = (this.results.total / totalTests) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        updateUI() {
            document.getElementById('totalTests').textContent = this.results.total;
            document.getElementById('passedTests').textContent = this.results.passed;
            document.getElementById('failedTests').textContent = this.results.failed;

            const coverage = this.results.total > 0
                ? Math.round((this.results.passed / this.results.total) * 100)
                : 0;
            document.getElementById('coverage').textContent = `${coverage}%`;
        }

        updateTestUI(suiteName, test) {
            const suiteElement = document.getElementById(`suite-${this.sanitizeId(suiteName)}`);
            if (!suiteElement) {
                this.createSuiteUI(suiteName);
            }

            const testElement = document.getElementById(`test-${this.sanitizeId(suiteName)}-${this.sanitizeId(test.name)}`);
            if (testElement) {
                testElement.className = `test-item ${test.status}`;

                const statusElement = testElement.querySelector('.test-status');
                const icon = test.status === 'passed' ? '‚úÖ' :
                    test.status === 'failed' ? '‚ùå' : '‚è≥';

                statusElement.innerHTML = `
                        <span class="status-icon">${icon}</span>
                        <span class="test-duration">${Math.round(test.duration)}ms</span>
                    `;

                if (test.error) {
                    let errorElement = testElement.querySelector('.test-error');
                    if (!errorElement) {
                        errorElement = document.createElement('div');
                        errorElement.className = 'test-error';
                        testElement.appendChild(errorElement);
                    }
                    errorElement.textContent = test.error;
                }
            }
        }

        createSuiteUI(suiteName) {
            const resultsContainer = document.getElementById('testResults');
            const suite = this.suites.get(suiteName);

            const suiteElement = document.createElement('div');
            suiteElement.className = 'test-suite';
            suiteElement.id = `suite-${this.sanitizeId(suiteName)}`;

            const header = document.createElement('div');
            header.className = 'suite-header';
            header.onclick = () => this.toggleSuite(suiteName);

            header.innerHTML = `
                    <div class="suite-title">
                        <span>üìÅ</span>
                        ${suiteName}
                    </div>
                    <div class="suite-stats">${suite.tests.length} tests</div>
                `;

            const testList = document.createElement('div');
            testList.className = 'test-list collapsible expanded';
            testList.id = `tests-${this.sanitizeId(suiteName)}`;

            suite.tests.forEach(test => {
                const testElement = document.createElement('div');
                testElement.className = 'test-item pending';
                testElement.id = `test-${this.sanitizeId(suiteName)}-${this.sanitizeId(test.name)}`;

                testElement.innerHTML = `
                        <div class="test-name">${test.name}</div>
                        <div class="test-status">
                            <span class="status-icon">‚è≥</span>
                            <span class="test-duration">0ms</span>
                        </div>
                    `;

                testList.appendChild(testElement);
            });

            suiteElement.appendChild(header);
            suiteElement.appendChild(testList);
            resultsContainer.appendChild(suiteElement);
        }

        toggleSuite(suiteName) {
            const testList = document.getElementById(`tests-${this.sanitizeId(suiteName)}`);
            if (testList) {
                testList.classList.toggle('expanded');
            }
        }

        sanitizeId(str) {
            return str.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        }

        log(message) {
            this.console.push(`[${new Date().toLocaleTimeString()}] ${message}`);
            this.updateConsole();
        }

        updateConsole() {
            const consoleElement = document.getElementById('consoleOutput');
            const consoleText = document.getElementById('consoleText');

            if (this.console.length > 0) {
                consoleElement.style.display = 'block';
                consoleText.innerHTML = this.console.join('<br>');
                consoleText.scrollTop = consoleText.scrollHeight;
            }
        }

        showResults() {
            const passed = this.results.passed;
            const failed = this.results.failed;
            const total = this.results.total;

            this.log(`
                    üèÅ Test Suite Complete
                    ‚úÖ Passed: ${passed}
                    ‚ùå Failed: ${failed}
                    üìä Total: ${total}
                    üìà Success Rate: ${total > 0 ? Math.round((passed/total) * 100) : 0}%
                `);
        }

        clear() {
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('consoleOutput').style.display = 'none';
            document.getElementById('progressFill').style.width = '0%';
            this.results = { total: 0, passed: 0, failed: 0, running: false };
            this.console = [];
            this.updateUI();
        }
    }

    // Mock implementations for testing
    const MockData = {
        validReminder: {
            title: 'Test Reminder',
            description: 'Test Description',
            datetime: new Date(Date.now() + 3600000).toISOString(),
            category: 'personal',
            priority: 2,
            notification: true,
            alertTimings: [5, 15]
        },

        invalidReminder: {
            title: '',
            datetime: new Date(Date.now() - 3600000).toISOString(),
            priority: 5
        },

        validUser: {
            username: 'testuser',
            password: 'password123',
            role: 'user'
        }
    };

    // Mock Storage Implementation
    class MockStorage {
        constructor() {
            this.data = new Map();
            this.initialized = false;
        }

        async initialize() {
            this.initialized = true;
            return true;
        }

        async saveReminder(reminder) {
            if (!this.initialized) throw new Error('Storage not initialized');

            const id = reminder.id || this.generateId();
            const savedReminder = { ...reminder, id, updatedAt: new Date().toISOString() };
            this.data.set(id, savedReminder);
            return savedReminder;
        }

        async getReminders(userId) {
            if (!this.initialized) throw new Error('Storage not initialized');

            return Array.from(this.data.values())
                .filter(r => r.userId === userId);
        }

        async getReminderById(id) {
            return this.data.get(id) || null;
        }

        async updateReminder(id, updates) {
            const existing = this.data.get(id);
            if (!existing) throw new Error('Reminder not found');

            const updated = { ...existing, ...updates, updatedAt: new Date().toISOString() };
            this.data.set(id, updated);
            return updated;
        }

        async deleteReminder(id) {
            return this.data.delete(id);
        }

        generateId() {
            return 'test-' + Math.random().toString(36).substr(2, 9);
        }

        async healthCheck() {
            return { healthy: this.initialized, type: 'Mock' };
        }
    }

    // Test Framework Instance
    const testFramework = new TestFramework();

    // === STORAGE TESTS ===
    testFramework.suite('Storage Layer Tests');

    testFramework.test('Storage Layer Tests', 'Mock Storage Initialization', async () => {
        const storage = new MockStorage();
        const result = await storage.initialize();

        if (!result) throw new Error('Storage initialization failed');
        if (!storage.initialized) throw new Error('Storage not marked as initialized');
    });

    testFramework.test('Storage Layer Tests', 'Save Reminder', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        const reminder = { ...MockData.validReminder, userId: 'test-user' };
        const saved = await storage.saveReminder(reminder);

        if (!saved.id) throw new Error('Saved reminder missing ID');
        if (!saved.updatedAt) throw new Error('Saved reminder missing timestamp');
        if (saved.title !== reminder.title) throw new Error('Title mismatch');
    });

    testFramework.test('Storage Layer Tests', 'Retrieve Reminders', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        const reminder1 = { ...MockData.validReminder, userId: 'user1', title: 'Reminder 1' };
        const reminder2 = { ...MockData.validReminder, userId: 'user1', title: 'Reminder 2' };
        const reminder3 = { ...MockData.validReminder, userId: 'user2', title: 'Reminder 3' };

        await storage.saveReminder(reminder1);
        await storage.saveReminder(reminder2);
        await storage.saveReminder(reminder3);

        const user1Reminders = await storage.getReminders('user1');
        const user2Reminders = await storage.getReminders('user2');

        if (user1Reminders.length !== 2) throw new Error('User1 should have 2 reminders');
        if (user2Reminders.length !== 1) throw new Error('User2 should have 1 reminder');
    });

    testFramework.test('Storage Layer Tests', 'Update Reminder', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        const original = await storage.saveReminder({ ...MockData.validReminder, userId: 'test' });
        const updated = await storage.updateReminder(original.id, { title: 'Updated Title' });

        if (updated.title !== 'Updated Title') throw new Error('Title not updated');
        if (updated.id !== original.id) throw new Error('ID changed during update');
    });

    testFramework.test('Storage Layer Tests', 'Delete Reminder', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        const saved = await storage.saveReminder({ ...MockData.validReminder, userId: 'test' });
        const deleted = await storage.deleteReminder(saved.id);
        const retrieved = await storage.getReminderById(saved.id);

        if (!deleted) throw new Error('Delete operation failed');
        if (retrieved !== null) throw new Error('Reminder still exists after deletion');
    });

    // === VALIDATION TESTS ===
    testFramework.suite('Validation Tests');

    testFramework.test('Validation Tests', 'Valid Reminder Validation', async () => {
        const reminder = MockData.validReminder;

        // Basic validation checks
        if (!reminder.title || reminder.title.trim() === '') {
            throw new Error('Title validation failed');
        }

        if (new Date(reminder.datetime) <= new Date()) {
            throw new Error('DateTime should be in future');
        }

        if (![1, 2, 3, 4].includes(reminder.priority)) {
            throw new Error('Priority validation failed');
        }

        if (!Array.isArray(reminder.alertTimings)) {
            throw new Error('Alert timings should be array');
        }
    });

    testFramework.test('Validation Tests', 'Invalid Reminder Validation', async () => {
        const reminder = MockData.invalidReminder;
        let errorCount = 0;

        if (!reminder.title || reminder.title.trim() === '') errorCount++;
        if (new Date(reminder.datetime) <= new Date()) errorCount++;
        if (![1, 2, 3, 4].includes(reminder.priority)) errorCount++;

        if (errorCount !== 3) throw new Error(`Expected 3 validation errors, got ${errorCount}`);
    });

    testFramework.test('Validation Tests', 'User Credentials Validation', async () => {
        const user = MockData.validUser;

        if (!user.username || user.username.length < 3) {
            throw new Error('Username validation failed');
        }

        if (!user.password || user.password.length < 6) {
            throw new Error('Password validation failed');
        }

        const usernamePattern = /^[a-zA-Z0-9_-]+$/;
        if (!usernamePattern.test(user.username)) {
            throw new Error('Username pattern validation failed');
        }
    });

    // === SERVICE TESTS ===
    testFramework.suite('Service Layer Tests');

    testFramework.test('Service Layer Tests', 'Authentication Service Mock', async () => {
        const credentials = { username: 'admin', password: 'password123' };

        // Mock authentication logic
        const validUsers = { admin: 'password123', user: 'userpass123' };
        const isValid = validUsers[credentials.username] === credentials.password;

        if (!isValid) throw new Error('Authentication failed');

        const session = {
            username: credentials.username,
            loginTime: new Date().toISOString(),
            expiresAt: Date.now() + 24 * 60 * 60 * 1000
        };

        if (!session.username) throw new Error('Session creation failed');
    });

    testFramework.test('Service Layer Tests', 'Notification Scheduling', async () => {
        const reminder = MockData.validReminder;
        const alertTimings = reminder.alertTimings;

        let scheduledCount = 0;

        // Mock notification scheduling
        alertTimings.forEach(timing => {
            const alertTime = new Date(reminder.datetime);
            alertTime.setMinutes(alertTime.getMinutes() - timing);

            if (alertTime > new Date()) {
                scheduledCount++;
            }
        });

        if (scheduledCount === 0) throw new Error('No notifications scheduled');
    });

    // === INTEGRATION TESTS ===
    testFramework.suite('Integration Tests');

    testFramework.test('Integration Tests', 'Full Reminder Lifecycle', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        // Create
        const reminder = { ...MockData.validReminder, userId: 'integration-test' };
        const created = await storage.saveReminder(reminder);

        // Read
        const retrieved = await storage.getReminderById(created.id);
        if (!retrieved) throw new Error('Failed to retrieve created reminder');

        // Update
        const updated = await storage.updateReminder(created.id, {
            title: 'Updated Title',
            status: 'completed'
        });
        if (updated.title !== 'Updated Title') throw new Error('Update failed');

        // Delete
        const deleted = await storage.deleteReminder(created.id);
        if (!deleted) throw new Error('Delete failed');

        const afterDelete = await storage.getReminderById(created.id);
        if (afterDelete !== null) throw new Error('Reminder still exists after delete');
    });

    testFramework.test('Integration Tests', 'Multi-User Data Isolation', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        const user1Reminder = { ...MockData.validReminder, userId: 'user1' };
        const user2Reminder = { ...MockData.validReminder, userId: 'user2' };

        await storage.saveReminder(user1Reminder);
        await storage.saveReminder(user2Reminder);

        const user1Data = await storage.getReminders('user1');
        const user2Data = await storage.getReminders('user2');

        if (user1Data.length !== 1) throw new Error('User1 data isolation failed');
        if (user2Data.length !== 1) throw new Error('User2 data isolation failed');
        if (user1Data[0].userId !== 'user1') throw new Error('Data mixed between users');
    });

    // === BROWSER COMPATIBILITY TESTS ===
    testFramework.suite('Browser Compatibility');

    testFramework.test('Browser Compatibility', 'Local Storage Available', async () => {
        if (typeof Storage === 'undefined') {
            throw new Error('Storage API not available');
        }

        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
        } catch (error) {
            throw new Error('localStorage not functional');
        }
    });

    testFramework.test('Browser Compatibility', 'IndexedDB Available', async () => {
        if (!('indexedDB' in window)) {
            throw new Error('IndexedDB not available');
        }

        // Test basic IndexedDB operation
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('test-db', 1);
            request.onerror = () => reject(new Error('IndexedDB open failed'));
            request.onsuccess = () => {
                request.result.close();
                indexedDB.deleteDatabase('test-db');
                resolve();
            };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                db.createObjectStore('test', { keyPath: 'id' });
            };
        });
    });

    testFramework.test('Browser Compatibility', 'Notification API Available', async () => {
        if (!('Notification' in window)) {
            throw new Error('Notification API not available');
        }

        // Check permission state
        const permission = Notification.permission;
        if (!['granted', 'denied', 'default'].includes(permission)) {
            throw new Error('Invalid notification permission state');
        }
    });

    testFramework.test('Browser Compatibility', 'Modern JavaScript Features', async () => {
        // Test ES6+ features used in the app
        try {
            // Arrow functions
            const arrow = () => 'test';
            if (arrow() !== 'test') throw new Error('Arrow functions not working');

            // Template literals
            const template = `Hello ${'World'}`;
            if (template !== 'Hello World') throw new Error('Template literals not working');

            // Destructuring
            const { a } = { a: 1 };
            if (a !== 1) throw new Error('Destructuring not working');

            // Async/await (already testing this by using async)
            await new Promise(resolve => setTimeout(resolve, 1));

            // Classes
            class TestClass { constructor() { this.test = true; } }
            const instance = new TestClass();
            if (!instance.test) throw new Error('Classes not working');

        } catch (error) {
            throw new Error(`JavaScript feature test failed: ${error.message}`);
        }
    });

    // === PERFORMANCE TESTS ===
    testFramework.suite('Performance Tests');

    testFramework.test('Performance Tests', 'Storage Operations Speed', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        const startTime = performance.now();

        // Perform multiple operations
        for (let i = 0; i < 100; i++) {
            const reminder = {
                ...MockData.validReminder,
                userId: 'perf-test',
                title: `Performance Test ${i}`
            };
            await storage.saveReminder(reminder);
        }

        const endTime = performance.now();
        const duration = endTime - startTime;

        // Should complete 100 operations in under 1 second
        if (duration > 1000) {
            throw new Error(`Operations too slow: ${duration}ms for 100 operations`);
        }
    });

    testFramework.test('Performance Tests', 'Memory Usage Check', async () => {
        if (!('memory' in performance)) {
            console.log('Memory API not available, skipping test');
            return;
        }

        const initialMemory = performance.memory.usedJSHeapSize;

        // Create many objects
        const objects = [];
        for (let i = 0; i < 1000; i++) {
            objects.push({ ...MockData.validReminder, id: i });
        }

        const peakMemory = performance.memory.usedJSHeapSize;

        // Clear objects
        objects.length = 0;

        // Force garbage collection if available
        if (window.gc) window.gc();

        const memoryIncrease = peakMemory - initialMemory;

        // Memory increase should be reasonable
        if (memoryIncrease > 10 * 1024 * 1024) { // 10MB
            throw new Error(`Excessive memory usage: ${memoryIncrease} bytes`);
        }
    });

    // === ERROR HANDLING TESTS ===
    testFramework.suite('Error Handling Tests');

    testFramework.test('Error Handling Tests', 'Storage Error Handling', async () => {
        const storage = new MockStorage();

        // Test operations without initialization
        try {
            await storage.saveReminder(MockData.validReminder);
            throw new Error('Should have thrown initialization error');
        } catch (error) {
            if (!error.message.includes('not initialized')) {
                throw new Error('Wrong error type thrown');
            }
        }
    });

    testFramework.test('Error Handling Tests', 'Invalid Data Handling', async () => {
        const storage = new MockStorage();
        await storage.initialize();

        // Test null/undefined data
        try {
            await storage.saveReminder(null);
            // Should handle gracefully or throw appropriate error
        } catch (error) {
            // Expected behavior
        }

        // Test invalid reminder ID
        const result = await storage.getReminderById('nonexistent-id');
        if (result !== null) {
            throw new Error('Should return null for invalid ID');
        }
    });

    testFramework.test('Error Handling Tests', 'Network Simulation', async () => {
        // Simulate network timeout
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Network timeout')), 100);
        });

        try {
            await timeoutPromise;
            throw new Error('Should have timed out');
        } catch (error) {
            if (!error.message.includes('timeout')) {
                throw new Error('Wrong timeout error');
            }
        }
    });

    // === UTILITY FUNCTION TESTS ===
    testFramework.suite('Utility Function Tests');

    testFramework.test('Utility Function Tests', 'ID Generation', async () => {
        const storage = new MockStorage();
        const id1 = storage.generateId();
        const id2 = storage.generateId();

        if (!id1 || !id2) throw new Error('ID generation failed');
        if (id1 === id2) throw new Error('IDs should be unique');
        if (typeof id1 !== 'string') throw new Error('ID should be string');
    });

    testFramework.test('Utility Function Tests', 'Date Validation', async () => {
        const now = new Date();
        const future = new Date(now.getTime() + 3600000);
        const past = new Date(now.getTime() - 3600000);

        if (future <= now) throw new Error('Future date validation failed');
        if (past >= now) throw new Error('Past date validation failed');

        const isoString = future.toISOString();
        const parsed = new Date(isoString);
        if (isNaN(parsed.getTime())) throw new Error('ISO string parsing failed');
    });

    testFramework.test('Utility Function Tests', 'Array Operations', async () => {
        const testArray = [1, 2, 3, 4, 5];

        // Test filtering
        const filtered = testArray.filter(x => x > 3);
        if (filtered.length !== 2) throw new Error('Filter operation failed');

        // Test mapping
        const mapped = testArray.map(x => x * 2);
        if (mapped[0] !== 2) throw new Error('Map operation failed');

        // Test finding
        const found = testArray.find(x => x === 3);
        if (found !== 3) throw new Error('Find operation failed');
    });

    // === SECURITY TESTS ===
    testFramework.suite('Security Tests');

    testFramework.test('Security Tests', 'XSS Prevention', async () => {
        const maliciousInput = '<script>alert("xss")</script>';

// Test HTML escaping
const div = document.createElement('div');
div.textContent = maliciousInput;
const escaped = div.innerHTML;

if (escaped.includes('<script>')) {
throw new Error('XSS vulnerability detected');
}
});

testFramework.test('Security Tests', 'Data Sanitization', async () => {
    const unsafeData = {
        title: '<script>alert("xss")</script>',
description: 'javascript:alert("xss")',
userInput: '"><script>alert("xss")</script>'
};

// Simulate sanitization
const sanitized = {
title: unsafeData.title.replace(/<[^>]*>/g, ''),
description: unsafeData.description.replace(/javascript:/gi, ''),
userInput: unsafeData.userInput.replace(/[<>"']/g, '')
};

if (sanitized.title.includes('<script>')) throw new Error('Title sanitization failed');
if (sanitized.description.includes('javascript:')) throw new Error('Description sanitization failed');
if (sanitized.userInput.includes('<') || sanitized.userInput.includes('>')) {
    throw new Error('User input sanitization failed');
}
});

// === UI COMPONENT TESTS ===
testFramework.suite('UI Component Tests');

testFramework.test('UI Component Tests', 'Modal Creation', async () => {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Test Modal</h2>
                        <button class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">Test Content</div>
                </div>
            `;

    document.body.appendChild(modal);

    if (!modal.querySelector('.modal-header')) {
        throw new Error('Modal header not created');
    }

    if (!modal.querySelector('.modal-close')) {
        throw new Error('Modal close button not created');
    }

    document.body.removeChild(modal);
});

testFramework.test('UI Component Tests', 'Form Validation UI', async () => {
    const form = document.createElement('form');
    form.innerHTML = `
                <input type="text" name="title" required>
                <input type="datetime-local" name="datetime" required>
                <select name="priority">
                    <option value="1">Low</option>
                    <option value="2">Medium</option>
                    <option value="3">High</option>
                    <option value="4">Urgent</option>
                </select>
            `;

    document.body.appendChild(form);

    const titleInput = form.querySelector('input[name="title"]');
    const datetimeInput = form.querySelector('input[name="datetime"]');
    const prioritySelect = form.querySelector('select[name="priority"]');

    if (!titleInput || !datetimeInput || !prioritySelect) {
        throw new Error('Form elements not created properly');
    }

    // Test form data extraction
    titleInput.value = 'Test Title';
    datetimeInput.value = '2024-12-31T23:59';
    prioritySelect.value = '3';

    const formData = new FormData(form);
    const data = Object.fromEntries(formData);

    if (data.title !== 'Test Title') throw new Error('Form data extraction failed');
    if (data.priority !== '3') throw new Error('Select value extraction failed');

    document.body.removeChild(form);
});

// === DATA PERSISTENCE TESTS ===
testFramework.suite('Data Persistence Tests');

testFramework.test('Data Persistence Tests', 'Export/Import Functionality', async () => {
    const storage = new MockStorage();
    await storage.initialize();

    // Create test data
    const reminders = [];
    for (let i = 0; i < 5; i++) {
        const reminder = await storage.saveReminder({
            ...MockData.validReminder,
            userId: 'export-test',
            title: `Export Test ${i}`
        });
        reminders.push(reminder);
    }

    // Export data
    const exportData = {
        version: '2.0',
        timestamp: new Date().toISOString(),
        data: {
            reminders: await storage.getReminders('export-test'),
            preferences: null
        }
    };

    // Validate export structure
    if (!exportData.version) throw new Error('Export missing version');
    if (!exportData.timestamp) throw new Error('Export missing timestamp');
    if (!Array.isArray(exportData.data.reminders)) throw new Error('Export reminders not array');
    if (exportData.data.reminders.length !== 5) throw new Error('Export reminder count mismatch');

    // Test import (simulate)
    const importedReminders = exportData.data.reminders;
    let importedCount = 0;

    for (const reminder of importedReminders) {
        if (reminder.title && reminder.datetime) {
            importedCount++;
        }
    }

    if (importedCount !== 5) throw new Error('Import validation failed');
});

testFramework.test('Data Persistence Tests', 'Data Consistency Check', async () => {
    const storage = new MockStorage();
    await storage.initialize();

    const reminder = await storage.saveReminder({
        ...MockData.validReminder,
        userId: 'consistency-test'
    });

    // Update reminder multiple times
    let updated = reminder;
    for (let i = 0; i < 3; i++) {
        updated = await storage.updateReminder(updated.id, {
            title: `Updated Title ${i}`,
            updateCount: i + 1
        });
    }

    // Verify final state
    const final = await storage.getReminderById(reminder.id);

    if (final.title !== 'Updated Title 2') throw new Error('Final update not applied');
    if (final.updateCount !== 3) throw new Error('Update count inconsistent');
    if (final.id !== reminder.id) throw new Error('ID changed during updates');
});

// Event Listeners Setup
document.getElementById('runAllTests').addEventListener('click', async () => {
    document.getElementById('runAllTests').classList.add('loading');
    await testFramework.runAll();
    document.getElementById('runAllTests').classList.remove('loading');
});

document.getElementById('runUnitTests').addEventListener('click', async () => {
    document.getElementById('runUnitTests').classList.add('loading');
    await testFramework.runAll('validation');
    await testFramework.runAll('utility');
    document.getElementById('runUnitTests').classList.remove('loading');
});

document.getElementById('runIntegrationTests').addEventListener('click', async () => {
    document.getElementById('runIntegrationTests').classList.add('loading');
    await testFramework.runAll('integration');
    document.getElementById('runIntegrationTests').classList.remove('loading');
});

document.getElementById('runStorageTests').addEventListener('click', async () => {
    document.getElementById('runStorageTests').classList.add('loading');
    await testFramework.runAll('storage');
    await testFramework.runAll('persistence');
    document.getElementById('runStorageTests').classList.remove('loading');
});

document.getElementById('clearResults').addEventListener('click', () => {
    testFramework.clear();
});

// Auto-run basic tests on load
window.addEventListener('load', async () => {
    console.log('üß™ Test Suite Loaded - Ready to run tests!');

    // Show initial UI
    testFramework.updateUI();

    // Log browser info
    testFramework.log(`Browser: ${navigator.userAgent}`);
    testFramework.log(`Platform: ${navigator.platform}`);
    testFramework.log(`Language: ${navigator.language}`);

    // Auto-run compatibility tests
    setTimeout(async () => {
        testFramework.log('üîç Running initial compatibility check...');
        await testFramework.runAll('compatibility');
    }, 1000);
});

// Global error handler for test debugging
window.addEventListener('error', (event) => {
    testFramework.log(`üí• Global Error: ${event.error?.message || event.message}`);
});

window.addEventListener('unhandledrejection', (event) => {
    testFramework.log(`üö´ Unhandled Promise Rejection: ${event.reason?.message || event.reason}`);
});

</script>
</body>
</html>