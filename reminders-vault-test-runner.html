<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reminders Vault - Complete Test Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .test-runner {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px 30px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-section {
            padding: 20px 30px;
            background: #ffffff;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9, #27ae60);
            border-radius: 12px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .test-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: center;
            border-left: 4px solid;
        }

        .summary-card.total { border-left-color: #3498db; }
        .summary-card.passed { border-left-color: #27ae60; }
        .summary-card.failed { border-left-color: #e74c3c; }
        .summary-card.warnings { border-left-color: #f39c12; }

        .summary-number {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .test-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            min-height: 500px;
        }

        .test-log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            font-family: 'Courier New', monospace;
            overflow-y: auto;
            border-right: 1px solid #34495e;
        }

        .test-results {
            background: #ffffff;
            padding: 20px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px 12px;
            margin: 3px 0;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.4;
        }

        .log-success {
            background: rgba(39, 174, 96, 0.15);
            border-left: 3px solid #27ae60;
            color: #27ae60;
        }

        .log-error {
            background: rgba(231, 76, 60, 0.15);
            border-left: 3px solid #e74c3c;
            color: #e74c3c;
        }

        .log-warning {
            background: rgba(243, 156, 18, 0.15);
            border-left: 3px solid #f39c12;
            color: #f39c12;
        }

        .log-info {
            background: rgba(52, 152, 219, 0.15);
            border-left: 3px solid #3498db;
            color: #3498db;
        }

        .issues-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin: 20px;
            display: none;
        }

        .issue-item {
            background: white;
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid #f39c12;
        }

        .severity-critical { border-left-color: #e74c3c; }
        .severity-major { border-left-color: #f39c12; }
        .severity-minor { border-left-color: #3498db; }

        .export-section {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            text-align: center;
        }

        .export-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .test-sections {
                grid-template-columns: 1fr;
            }

            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }

            .test-controls {
                justify-content: center;
            }
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div class="test-runner">
    <div class="header">
        <h1>üß™ Reminders Vault Test Runner</h1>
        <p>Complete automated testing with issue detection and reporting</p>
    </div>

    <div class="control-panel">
        <div class="test-controls">
            <button class="btn btn-primary" id="runFullSuite">
                <span>üöÄ</span>
                Run Full Test Suite
            </button>
            <button class="btn btn-success" id="runQuickTests">
                <span>‚ö°</span>
                Quick Tests
            </button>
            <button class="btn btn-danger" id="runStressTests">
                <span>üí•</span>
                Stress Tests
            </button>
        </div>
        <div class="test-info">
            <span id="testTimer">00:00</span>
            <button class="btn" id="stopTests" style="display: none;">
                <span>‚èπÔ∏è</span>
                Stop
            </button>
        </div>
    </div>

    <div class="progress-section">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3>Test Progress</h3>
            <span id="progressText">Ready to start testing</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="test-summary">
            <div class="summary-card total">
                <div class="summary-number" id="totalTests">0</div>
                <div>Total Tests</div>
            </div>
            <div class="summary-card passed">
                <div class="summary-number" id="passedTests">0</div>
                <div>Passed</div>
            </div>
            <div class="summary-card failed">
                <div class="summary-number" id="failedTests">0</div>
                <div>Failed</div>
            </div>
            <div class="summary-card warnings">
                <div class="summary-number" id="warningTests">0</div>
                <div>Warnings</div>
            </div>
        </div>
    </div>

    <div class="test-sections">
        <div class="test-log">
            <h3 style="margin-bottom: 15px; color: #ecf0f1;">üìã Test Log</h3>
            <div id="logContainer">
                <div class="log-entry log-info">
                    Test runner ready. Click 'Run Full Test Suite' to begin comprehensive testing.
                </div>
            </div>
        </div>
        <div class="test-results">
            <h3 style="margin-bottom: 15px; color: #2c3e50;">üìä Test Results</h3>
            <div id="testResults">
                <p>No tests run yet. Use the buttons above to start testing.</p>
            </div>
        </div>
    </div>

    <div class="issues-section" id="issuesSection">
        <h3>‚ö†Ô∏è Issues Found</h3>
        <div id="issuesList"></div>
    </div>

    <div class="export-section">
        <h3>üì§ Export Test Results</h3>
        <div class="export-controls">
            <button class="btn btn-primary" id="exportJson">
                <span>üìÑ</span>
                Export JSON
            </button>
            <button class="btn btn-success" id="exportHtml">
                <span>üåê</span>
                Export HTML Report
            </button>
            <button class="btn" id="clearResults">
                <span>üßπ</span>
                Clear Results
            </button>
        </div>
    </div>
</div>

<script>
    // Constants for better type safety and consistency
    const TestTypes = Object.freeze({
        SUCCESS: 'success',
        ERROR: 'error',
        WARNING: 'warning',
        INFO: 'info'
    });

    const IssueSeverity = Object.freeze({
        CRITICAL: 'critical',
        MAJOR: 'major',
        MINOR: 'minor'
    });

    const TestConfig = Object.freeze({
        TIMEOUT_MS: 5000,
        MEMORY_LEAK_THRESHOLD_MB: 2,
        PERFORMANCE_THRESHOLD_MS: 1000,
        ACCESSIBILITY_MIN_SCORE: 70
    });

    // Data structures for better organization
    class TestResult {
        constructor(type, message, timestamp = new Date()) {
            this.type = type;
            this.message = message;
            this.timestamp = timestamp.toISOString();
        }
    }

    class Issue {
        constructor(severity, category, title, description, recommendation = '') {
            this.severity = severity;
            this.category = category;
            this.title = title;
            this.description = description;
            this.recommendation = recommendation;
            this.timestamp = new Date().toISOString();
        }
    }

    class BrowserInfo {
        constructor() {
            this.userAgent = navigator.userAgent;
            this.platform = navigator.platform;
            this.language = navigator.language;
            this.cookieEnabled = navigator.cookieEnabled;
            this.onLine = navigator.onLine;
            this.parsed = this.parseBrowser();
        }

        parseBrowser() {
            const ua = this.userAgent;
            const browsers = [
                { name: 'Chrome', pattern: /Chrome\/(\d+)/, exclude: [] },
                { name: 'Firefox', pattern: /Firefox\/(\d+)/, exclude: [] },
                { name: 'Safari', pattern: /Version\/(\d+)/, exclude: ['Chrome'] },
                { name: 'Edge', pattern: /Edge\/(\d+)/, exclude: [] }
            ];

            for (const browser of browsers) {
                if (browser.exclude.some(exclude => ua.includes(exclude))) continue;

                if (ua.includes(browser.name) || browser.name === 'Safari') {
                    const match = ua.match(browser.pattern);
                    if (match) {
                        return { name: browser.name, version: match[1] };
                    }
                }
            }

            return { name: 'Unknown', version: 'Unknown' };
        }
    }

    // Main test runner class with proper encapsulation
    class ReminderVaultTestRunner {
        constructor() {
            this.testResults = { total: 0, passed: 0, failed: 0, warnings: 0 };
            this.issues = [];
            this.testLog = [];
            this.isRunning = false;
            this.startTime = null;
            this.timerInterval = null;
            this.currentTest = 0;
            this.totalTestsToRun = 0;
            this.abortController = null;
            this.browserInfo = new BrowserInfo();
            this.finalReport = null;

            this.init();
        }

        init() {
            this.setupEventListeners();
            this.log(TestTypes.INFO, 'üöÄ Test runner initialized and ready');
        }

        setupEventListeners() {
            const eventMap = new Map([
                ['runFullSuite', () => this.runFullTestSuite()],
                ['runQuickTests', () => this.runQuickTests()],
                ['runStressTests', () => this.runStressTests()],
                ['stopTests', () => this.stopTests()],
                ['exportJson', () => this.exportResults('json')],
                ['exportHtml', () => this.exportResults('html')],
                ['clearResults', () => this.clearResults()]
            ]);

            eventMap.forEach((handler, id) => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('click', handler);
                }
            });
        }

        log(type, message) {
            const testResult = new TestResult(type, message);
            this.testLog.push(testResult);

            this.renderLogEntry(testResult);
            this.updateCounters(type);
            this.updateSummary();
        }

        renderLogEntry(testResult) {
            const logContainer = document.getElementById('logContainer');
            if (!logContainer) return;

            const logDiv = document.createElement('div');
            logDiv.className = `log-entry log-${testResult.type}`;
            logDiv.innerHTML = `[${new Date(testResult.timestamp).toLocaleTimeString()}] ${testResult.message}`;

            logContainer.appendChild(logDiv);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        updateCounters(type) {
            this.testResults.total++;

            const counterMap = {
                [TestTypes.SUCCESS]: 'passed',
                [TestTypes.ERROR]: 'failed',
                [TestTypes.WARNING]: 'warnings'
            };

            if (counterMap[type]) {
                this.testResults[counterMap[type]]++;
            }
        }

        updateSummary() {
            const summaryElements = {
                totalTests: this.testResults.total,
                passedTests: this.testResults.passed,
                failedTests: this.testResults.failed,
                warningTests: this.testResults.warnings
            };

            Object.entries(summaryElements).forEach(([id, value]) => {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            });

            this.updateProgressBar();
        }

        updateProgressBar() {
            const progress = this.totalTestsToRun > 0
                ? (this.currentTest / this.totalTestsToRun) * 100
                : (this.testResults.total > 0 ? (this.testResults.passed / this.testResults.total) * 100 : 0);

            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${Math.min(progress, 100)}%`;
            }
        }

        addIssue(severity, category, title, description, recommendation = '') {
            const issue = new Issue(severity, category, title, description, recommendation);
            this.issues.push(issue);
            this.updateIssuesDisplay();
        }

        updateIssuesDisplay() {
            const issuesSection = document.getElementById('issuesSection');
            const issuesList = document.getElementById('issuesList');

            if (!issuesSection || !issuesList) return;

            if (this.issues.length === 0) {
                issuesSection.style.display = 'none';
                return;
            }

            issuesSection.style.display = 'block';
            issuesList.innerHTML = this.issues.map(issue => `
                <div class="issue-item severity-${issue.severity}">
                    <div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">
                        ${issue.severity.toUpperCase()}: ${issue.title}
                    </div>
                    <div style="margin-bottom: 8px;">${issue.description}</div>
                    ${issue.recommendation ? `<div style="font-style: italic; color: #666;"><strong>Recommendation:</strong> ${issue.recommendation}</div>` : ''}
                </div>
            `).join('');
        }

        startTimer() {
            this.startTime = Date.now();
            this.timerInterval = setInterval(() => {
                const elapsed = Date.now() - this.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);

                const timerElement = document.getElementById('testTimer');
                if (timerElement) {
                    timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        stopTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }

        setRunningState(isRunning) {
            this.isRunning = isRunning;

            const runButton = document.getElementById('runFullSuite');
            const stopButton = document.getElementById('stopTests');

            if (runButton) runButton.disabled = isRunning;
            if (stopButton) stopButton.style.display = isRunning ? 'inline-flex' : 'none';
        }

        updateProgressText(text) {
            const progressText = document.getElementById('progressText');
            if (progressText) progressText.textContent = text;
        }

        async sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async withTimeout(promise, timeoutMs, errorMessage) {
            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error(errorMessage)), timeoutMs)
            );

            return Promise.race([promise, timeoutPromise]);
        }

        // Main test suite execution
        async runFullTestSuite() {
            if (this.isRunning) return;

            this.setRunningState(true);
            this.currentTest = 0;
            this.totalTestsToRun = 50;
            this.abortController = new AbortController();
            this.startTimer();
            this.updateProgressText('Running comprehensive test suite...');

            this.log(TestTypes.INFO, 'üöÄ Starting comprehensive test suite...');

            try {
                const testSuites = [
                    () => this.runBrowserCompatibilityTests(),
                    () => this.runStorageSystemTests(),
                    () => this.runCRUDOperationTests(),
                    () => this.runNotificationTests(),
                    () => this.runUITests(),
                    () => this.runPerformanceTests(),
                    () => this.runSecurityTests(),
                    () => this.runAccessibilityTests()
                ];

                for (const testSuite of testSuites) {
                    if (this.abortController.signal.aborted) break;
                    await testSuite();
                    await this.sleep(100);
                }

                if (!this.abortController.signal.aborted) {
                    this.generateFinalReport();
                    this.log(TestTypes.SUCCESS, '‚úÖ All tests completed successfully!');
                    this.updateProgressText('All tests completed');
                }
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Test suite failed: ${error.message}`);
                this.updateProgressText('Tests failed');
            } finally {
                this.setRunningState(false);
                this.stopTimer();
                this.currentTest = 0;
                this.abortController = null;
            }
        }

        async runQuickTests() {
            this.log(TestTypes.INFO, '‚ö° Running quick validation tests...');
            this.updateProgressText('Running quick tests...');

            try {
                await this.testBasicBrowserSupport();
                await this.testLocalStorageBasics();
                await this.testNotificationPermissions();
                await this.testBasicDOMStructure();

                this.log(TestTypes.SUCCESS, '‚úÖ Quick tests completed');
                this.updateProgressText('Quick tests completed');
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Quick tests failed: ${error.message}`);
                this.updateProgressText('Quick tests failed');
            }
        }

        async runStressTests() {
            this.log(TestTypes.INFO, 'üí• Running stress tests...');
            this.updateProgressText('Running stress tests...');

            try {
                await this.testLargeDataHandling();
                await this.testMemoryLeaks();
                await this.testConcurrentOperations();
                await this.testErrorRecovery();

                this.log(TestTypes.SUCCESS, '‚úÖ Stress tests completed');
                this.updateProgressText('Stress tests completed');
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Stress tests failed: ${error.message}`);
                this.updateProgressText('Stress tests failed');
            }
        }

        // Individual test implementations
        async runBrowserCompatibilityTests() {
            this.log(TestTypes.INFO, 'üåê Testing browser compatibility...');
            this.currentTest++;

            const { name, version } = this.browserInfo.parsed;
            this.log(TestTypes.INFO, `Browser: ${name} ${version}`);
            this.log(TestTypes.INFO, `Platform: ${this.browserInfo.platform}`);
            this.log(TestTypes.INFO, `Language: ${this.browserInfo.language}`);

            const criticalAPIs = {
                'localStorage': 'localStorage' in window,
                'sessionStorage': 'sessionStorage' in window,
                'indexedDB': 'indexedDB' in window,
                'Notifications': 'Notification' in window,
                'Promises': typeof Promise !== 'undefined',
                'Fetch API': 'fetch' in window,
                'Web Audio API': 'AudioContext' in window || 'webkitAudioContext' in window
            };

            let supportedAPIs = 0;
            Object.entries(criticalAPIs).forEach(([api, supported]) => {
                if (supported) {
                    supportedAPIs++;
                    this.log(TestTypes.SUCCESS, `‚úÖ ${api}: Supported`);
                } else {
                    this.log(TestTypes.ERROR, `‚ùå ${api}: Not supported`);
                    this.addIssue(IssueSeverity.CRITICAL, 'compatibility', `${api} Not Supported`,
                        `${api} is required for core functionality`,
                        'Update to a modern browser that supports this API');
                }
            });

            const totalAPIs = Object.keys(criticalAPIs).length;
            if (supportedAPIs < totalAPIs) {
                this.addIssue(IssueSeverity.CRITICAL, 'compatibility', 'Missing Browser APIs',
                    `Only ${supportedAPIs}/${totalAPIs} critical APIs supported`,
                    'Use a modern browser for full functionality');
            }

            this.currentTest += 5;
        }

        async runStorageSystemTests() {
            this.log(TestTypes.INFO, 'üíæ Testing storage systems...');

            await this.testLocalStorage();
            await this.testIndexedDB();
            await this.testStorageCapacity();

            this.currentTest += 8;
        }

        async testBasicBrowserSupport() {
            this.log(TestTypes.INFO, 'üîç Testing basic browser support...');

            const requiredFeatures = {
                'ES6 Classes': typeof class {} === 'function',
                'Arrow Functions': (() => true)(),
                'Template Literals': `test` === 'test',
                'Destructuring': (() => { try { const [a] = [1]; return true; } catch { return false; } })(),
                'Async/Await': typeof (async () => {}) === 'function'
            };

            Object.entries(requiredFeatures).forEach(([feature, supported]) => {
                if (supported) {
                    this.log(TestTypes.SUCCESS, `‚úÖ ${feature}: Supported`);
                } else {
                    this.log(TestTypes.ERROR, `‚ùå ${feature}: Not supported`);
                    this.addIssue(IssueSeverity.MAJOR, 'compatibility', `${feature} Not Supported`,
                        `Modern JavaScript feature ${feature} is not available`,
                        'Use a modern browser or enable JavaScript features');
                }
            });
        }

        async testLocalStorageBasics() {
            this.log(TestTypes.INFO, 'üíø Testing localStorage basics...');

            try {
                if (!('localStorage' in window)) {
                    throw new Error('localStorage not available');
                }

                const testKey = 'test_' + Date.now();
                const testData = { test: 'data', timestamp: Date.now() };

                localStorage.setItem(testKey, JSON.stringify(testData));
                const retrieved = JSON.parse(localStorage.getItem(testKey));

                if (retrieved.test !== 'data') {
                    throw new Error('Data integrity check failed');
                }

                localStorage.removeItem(testKey);

                if (localStorage.getItem(testKey) !== null) {
                    throw new Error('Delete operation failed');
                }

                this.log(TestTypes.SUCCESS, '‚úÖ localStorage basic operations working');
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå localStorage test failed: ${error.message}`);
                this.addIssue(IssueSeverity.CRITICAL, 'storage', 'localStorage Test Failed',
                    error.message,
                    'Check browser settings and localStorage availability');
            }
        }

        async testLocalStorage() {
            await this.testLocalStorageBasics();

            // Test quota handling
            try {
                const testKey = 'quota_test_' + Date.now();
                const largeData = 'x'.repeat(1000000); // 1MB
                localStorage.setItem(testKey, largeData);
                localStorage.removeItem(testKey);
                this.log(TestTypes.SUCCESS, '‚úÖ localStorage can handle large data');
            } catch (quotaError) {
                if (quotaError.name === 'QuotaExceededError') {
                    this.addIssue(IssueSeverity.MAJOR, 'storage', 'localStorage Quota Limited',
                        'localStorage storage space is limited',
                        'Implement data cleanup or use IndexedDB for large data');
                    this.log(TestTypes.WARNING, '‚ö†Ô∏è localStorage quota is limited');
                } else {
                    throw quotaError;
                }
            }
        }

        async testIndexedDB() {
            this.log(TestTypes.INFO, 'üóÉÔ∏è Testing IndexedDB functionality...');

            if (!('indexedDB' in window)) {
                this.addIssue(IssueSeverity.MAJOR, 'storage', 'IndexedDB Not Available',
                    'IndexedDB is not supported in this browser',
                    'Use a modern browser or implement fallback storage');
                this.log(TestTypes.WARNING, '‚ö†Ô∏è IndexedDB not available');
                return;
            }

            try {
                const dbName = 'TestDB_' + Date.now();

                await this.withTimeout(
                    new Promise((resolve, reject) => {
                        const request = indexedDB.open(dbName, 1);

                        request.onerror = () => reject(new Error(request.error?.message || 'IndexedDB connection failed'));
                        request.onsuccess = () => {
                            const db = request.result;
                            db.close();
                            indexedDB.deleteDatabase(dbName);
                            resolve(true);
                        };

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('test')) {
                                db.createObjectStore('test', { keyPath: 'id' });
                            }
                        };
                    }),
                    TestConfig.TIMEOUT_MS,
                    'IndexedDB connection timeout'
                );

                this.log(TestTypes.SUCCESS, '‚úÖ IndexedDB connection and operations working');
            } catch (error) {
                this.addIssue(IssueSeverity.MAJOR, 'storage', 'IndexedDB Test Failed',
                    error.message,
                    'Check browser compatibility and IndexedDB support');
                this.log(TestTypes.ERROR, `‚ùå IndexedDB test failed: ${error.message}`);
            }
        }

        async testStorageCapacity() {
            this.log(TestTypes.INFO, 'üìè Testing storage capacity...');

            if ('storage' in navigator && 'estimate' in navigator.storage) {
                try {
                    const estimate = await navigator.storage.estimate();
                    const quotaMB = Math.round(estimate.quota / 1024 / 1024);
                    const usageKB = Math.round(estimate.usage / 1024);
                    const usagePercent = (estimate.usage / estimate.quota) * 100;

                    this.log(TestTypes.INFO, `üìä Storage: ${quotaMB}MB quota, ${usageKB}KB used (${usagePercent.toFixed(1)}%)`);

                    if (usagePercent > 80) {
                        this.addIssue(IssueSeverity.MAJOR, 'storage', 'High Storage Usage',
                            `Storage usage is ${usagePercent.toFixed(1)}%`,
                            'Clear browser data or implement data cleanup');
                    } else {
                        this.log(TestTypes.SUCCESS, '‚úÖ Storage usage within acceptable limits');
                    }
                } catch (error) {
                    this.log(TestTypes.WARNING, `‚ö†Ô∏è Could not estimate storage capacity: ${error.message}`);
                }
            } else {
                this.log(TestTypes.WARNING, '‚ö†Ô∏è Storage estimation API not available');
            }
        }

        async runCRUDOperationTests() {
            this.log(TestTypes.INFO, 'üìù Testing CRUD operations...');

            const mockReminders = [];

            // Test Create
            try {
                for (let i = 0; i < 10; i++) {
                    const reminder = {
                        id: i,
                        title: `Test Reminder ${i}`,
                        description: `Test description ${i}`,
                        datetime: new Date(Date.now() + i * 3600000).toISOString(),
                        status: 'active'
                    };
                    mockReminders.push(reminder);
                }
                this.log(TestTypes.SUCCESS, `‚úÖ Created ${mockReminders.length} test reminders`);
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Create operation failed: ${error.message}`);
                this.addIssue(IssueSeverity.MAJOR, 'crud', 'Create Operation Failed',
                    'Unable to create reminder objects',
                    'Check reminder creation logic and validation');
            }

            // Test Read/Filter
            try {
                const activeReminders = mockReminders.filter(r => r.status === 'active');
                const sortedReminders = [...mockReminders].sort((a, b) => a.title.localeCompare(b.title));
                this.log(TestTypes.SUCCESS, `‚úÖ Read operations: ${activeReminders.length} active, ${sortedReminders.length} total`);
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Read operation failed: ${error.message}`);
            }

            // Test Update
            try {
                if (mockReminders.length > 0) {
                    mockReminders[0].title = 'Updated Reminder';
                    mockReminders[0].status = 'completed';
                    this.log(TestTypes.SUCCESS, '‚úÖ Update operation successful');
                }
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Update operation failed: ${error.message}`);
            }

            // Test Delete
            try {
                const initialCount = mockReminders.length;
                mockReminders.splice(0, 1);
                this.log(TestTypes.SUCCESS, `‚úÖ Delete operation: ${initialCount} ‚Üí ${mockReminders.length} reminders`);
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Delete operation failed: ${error.message}`);
            }

            this.currentTest += 10;
        }

        async runNotificationTests() {
            this.log(TestTypes.INFO, 'üîî Testing notification system...');

            await this.testNotificationPermissions();
            await this.testNotificationDisplay();
            await this.testAudioNotifications();

            this.currentTest += 8;
        }

        async testNotificationPermissions() {
            this.log(TestTypes.INFO, 'üîê Testing notification permissions...');

            if (!('Notification' in window)) {
                this.addIssue(IssueSeverity.MAJOR, 'notifications', 'Browser Notifications Not Supported',
                    'This browser does not support notifications',
                    'Use a modern browser or implement alternative notification methods');
                this.log(TestTypes.WARNING, '‚ö†Ô∏è Browser notifications not supported');
                return;
            }

            const permission = Notification.permission;
            this.log(TestTypes.INFO, `üîî Current permission: ${permission}`);

            switch (permission) {
                case 'denied':
                    this.addIssue(IssueSeverity.MAJOR, 'notifications', 'Notifications Denied',
                        'User has denied notification permissions',
                        'Provide instructions for enabling notifications');
                    this.log(TestTypes.WARNING, '‚ö†Ô∏è Notification permission denied');
                    break;
                case 'default':
                    this.log(TestTypes.INFO, 'üîî Notification permission not yet requested');
                    break;
                case 'granted':
                    this.log(TestTypes.SUCCESS, '‚úÖ Notification permissions granted');
                    break;
            }
        }

        async testNotificationDisplay() {
            this.log(TestTypes.INFO, 'üì± Testing notification display...');

            if (Notification.permission === 'granted') {
                try {
                    const testNotification = new Notification('Test Notification', {
                        body: 'This is a test notification from the test runner',
                        icon: '/favicon.png',
                        tag: 'test-notification'
                    });

                    setTimeout(() => testNotification.close(), 2000);
                    this.log(TestTypes.SUCCESS, '‚úÖ Browser notification display working');
                } catch (error) {
                    this.log(TestTypes.ERROR, `‚ùå Notification display failed: ${error.message}`);
                    this.addIssue(IssueSeverity.MINOR, 'notifications', 'Notification Display Error',
                        error.message,
                        'Check notification API implementation');
                }
            } else {
                this.log(TestTypes.WARNING, '‚ö†Ô∏è Cannot test browser notifications without permission');
            }

            // Test custom notification popup
            this.showTestNotification('Custom notification test', TestTypes.INFO);
            this.log(TestTypes.SUCCESS, '‚úÖ Custom notification display working');
        }

        async testAudioNotifications() {
            this.log(TestTypes.INFO, 'üîä Testing audio notifications...');

            try {
                if (!('AudioContext' in window || 'webkitAudioContext' in window)) {
                    this.addIssue(IssueSeverity.MINOR, 'notifications', 'Web Audio API Not Supported',
                        'Audio notifications not available',
                        'Provide visual-only notification fallback');
                    this.log(TestTypes.WARNING, '‚ö†Ô∏è Web Audio API not supported');
                    return;
                }

                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContext();

                if (audioContext.state === 'suspended') {
                    this.log(TestTypes.INFO, 'üîá Audio context suspended (user interaction required)');
                }

                // Test audio capability
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);

                this.log(TestTypes.SUCCESS, '‚úÖ Audio notification capability confirmed');
                await audioContext.close();

            } catch (error) {
                this.addIssue(IssueSeverity.MINOR, 'notifications', 'Audio Test Failed',
                    `Audio notifications may not work: ${error.message}`,
                    'Implement fallback notification methods');
                this.log(TestTypes.WARNING, `‚ö†Ô∏è Audio notification test: ${error.message}`);
            }
        }

        async runUITests() {
            this.log(TestTypes.INFO, 'üé® Testing user interface...');

            await this.testBasicDOMStructure();
            await this.testResponsiveDesign();
            await this.testAccessibilityFeatures();
            await this.testEventHandlers();

            this.currentTest += 10;
        }

        async testBasicDOMStructure() {
            this.log(TestTypes.INFO, 'üèóÔ∏è Testing DOM structure...');

            const requiredElements = [
                { selector: 'head', name: 'HTML Head' },
                { selector: 'meta[name="viewport"]', name: 'Viewport Meta Tag' },
                { selector: 'title', name: 'Page Title' },
                { selector: 'body', name: 'HTML Body' }
            ];

            let missingElements = 0;
            requiredElements.forEach(element => {
                const found = document.querySelector(element.selector);
                if (found) {
                    this.log(TestTypes.SUCCESS, `‚úÖ ${element.name} found`);
                } else {
                    this.log(TestTypes.ERROR, `‚ùå ${element.name} missing`);
                    this.addIssue(IssueSeverity.MINOR, 'ui', `Missing ${element.name}`,
                        `${element.name} not found in DOM`,
                        `Add ${element.selector} to the HTML`);
                    missingElements++;
                }
            });

            if (missingElements === 0) {
                this.log(TestTypes.SUCCESS, '‚úÖ Basic DOM structure is complete');
            }
        }

        async testResponsiveDesign() {
            this.log(TestTypes.INFO, 'üì± Testing responsive design...');

            const viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta) {
                this.log(TestTypes.SUCCESS, '‚úÖ Viewport meta tag found');
            } else {
                this.addIssue(IssueSeverity.MAJOR, 'ui', 'Missing Viewport Meta Tag',
                    'No viewport meta tag found',
                    'Add <meta name="viewport" content="width=device-width, initial-scale=1.0">');
            }

            // Test CSS media queries
            const breakpoints = [320, 768, 1024, 1440];
            breakpoints.forEach(width => {
                const mediaQuery = window.matchMedia(`(max-width: ${width}px)`);
                this.log(TestTypes.INFO, `üì± Breakpoint ${width}px: ${mediaQuery.matches ? 'Active' : 'Inactive'}`);
            });

            this.log(TestTypes.SUCCESS, '‚úÖ Responsive design checks completed');
        }

        async testAccessibilityFeatures() {
            this.log(TestTypes.INFO, '‚ôø Testing accessibility features...');

            let accessibilityScore = 0;
            const maxScore = 8;

            // Test for semantic HTML
            const semanticElements = document.querySelectorAll(
                'header, nav, main, article, section, aside, footer, h1, h2, h3, h4, h5, h6'
            );
            if (semanticElements.length > 0) {
                accessibilityScore += 2;
                this.log(TestTypes.SUCCESS, `‚úÖ Found ${semanticElements.length} semantic HTML elements`);
            } else {
                this.addIssue(IssueSeverity.MINOR, 'accessibility', 'Limited Semantic HTML',
                    'Few semantic HTML elements found',
                    'Use semantic HTML elements for better structure');
            }

            // Test for alt attributes on images
            const images = document.querySelectorAll('img');
            const imagesWithAlt = Array.from(images).filter(img => img.alt);
            if (images.length === 0 || imagesWithAlt.length === images.length) {
                accessibilityScore += 2;
                this.log(TestTypes.SUCCESS, '‚úÖ Image alt attributes check passed');
            } else {
                this.addIssue(IssueSeverity.MINOR, 'accessibility', 'Missing Alt Attributes',
                    `${images.length - imagesWithAlt.length} images missing alt text`,
                    'Add descriptive alt attributes to all images');
            }

            // Test for ARIA labels
            const elementsWithAria = document.querySelectorAll('[aria-label], [aria-labelledby], [role]');
            if (elementsWithAria.length > 0) {
                accessibilityScore += 2;
                this.log(TestTypes.SUCCESS, `‚úÖ Found ${elementsWithAria.length} elements with ARIA attributes`);
            } else {
                this.addIssue(IssueSeverity.MINOR, 'accessibility', 'Limited ARIA Usage',
                    'Few or no ARIA attributes found',
                    'Add ARIA labels and roles for better screen reader support');
            }

            // Test for focusable elements
            const focusableElements = document.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements.length > 0) {
                accessibilityScore += 2;
                this.log(TestTypes.SUCCESS, `‚úÖ Found ${focusableElements.length} focusable elements`);
            }

            const accessibilityPercentage = (accessibilityScore / maxScore) * 100;
            this.log(TestTypes.INFO, `‚ôø Accessibility score: ${accessibilityScore}/${maxScore} (${accessibilityPercentage}%)`);

            if (accessibilityPercentage < TestConfig.ACCESSIBILITY_MIN_SCORE) {
                this.addIssue(IssueSeverity.MAJOR, 'accessibility', 'Low Accessibility Score',
                    `Accessibility score is ${accessibilityPercentage}%`,
                    'Improve accessibility by adding ARIA labels, semantic HTML, and keyboard navigation');
            } else {
                this.log(TestTypes.SUCCESS, '‚úÖ Accessibility test passed');
            }
        }

        async testEventHandlers() {
            this.log(TestTypes.INFO, 'üñ±Ô∏è Testing event handlers...');

            try {
                let eventHandlerCount = 0;

                const testElement = document.createElement('button');
                testElement.textContent = 'Test Button';
                testElement.style.cssText = 'position: absolute; left: -9999px; opacity: 0;';
                document.body.appendChild(testElement);

                const testHandler = () => eventHandlerCount++;
                testElement.addEventListener('click', testHandler);

                // Simulate click
                testElement.click();

                if (eventHandlerCount === 1) {
                    this.log(TestTypes.SUCCESS, '‚úÖ Event handler functionality confirmed');
                }

                // Test event handler cleanup
                testElement.removeEventListener('click', testHandler);
                testElement.click();

                if (eventHandlerCount === 1) {
                    this.log(TestTypes.SUCCESS, '‚úÖ Event handler cleanup working');
                } else {
                    this.addIssue(IssueSeverity.MINOR, 'ui', 'Event Handler Cleanup Issues',
                        'Event handlers may not be properly removed',
                        'Ensure all event handlers are removed when elements are destroyed');
                }

                // Clean up
                document.body.removeChild(testElement);

            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Event handler test failed: ${error.message}`);
            }
        }

        async runPerformanceTests() {
            this.log(TestTypes.INFO, '‚ö° Testing performance...');

            await this.testPageLoadPerformance();
            await this.testMemoryUsage();
            await this.testLargeDataHandling();

            this.currentTest += 8;
        }

        async testPageLoadPerformance() {
            this.log(TestTypes.INFO, 'üöÄ Testing page load performance...');

            try {
                if (performance.timing && performance.timing.loadEventEnd) {
                    const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                    this.log(TestTypes.INFO, `üìä Page load time: ${loadTime}ms`);

                    if (loadTime > 3000) {
                        this.addIssue(IssueSeverity.MAJOR, 'performance', 'Slow Page Load',
                            `Page load time is ${loadTime}ms`,
                            'Optimize resources, minimize JavaScript, and compress assets');
                    } else {
                        this.log(TestTypes.SUCCESS, '‚úÖ Page load performance acceptable');
                    }
                } else {
                    this.log(TestTypes.WARNING, '‚ö†Ô∏è Performance timing API not available');
                }

                if (performance.timing && performance.timing.domContentLoadedEventEnd) {
                    const domReadyTime = performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart;
                    this.log(TestTypes.INFO, `üìä DOM ready time: ${domReadyTime}ms`);
                }

            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Page load performance test failed: ${error.message}`);
            }
        }

        async testMemoryUsage() {
            this.log(TestTypes.INFO, 'üß† Testing memory usage...');

            try {
                if (performance.memory) {
                    const memory = performance.memory;
                    const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                    const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                    const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);

                    this.log(TestTypes.INFO, `üìä Memory usage: ${usedMB}MB / ${totalMB}MB (limit: ${limitMB}MB)`);

                    const memoryUsagePercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;

                    if (memoryUsagePercent > 80) {
                        this.addIssue(IssueSeverity.MAJOR, 'performance', 'High Memory Usage',
                            `Memory usage is ${memoryUsagePercent.toFixed(1)}%`,
                            'Optimize memory usage and check for memory leaks');
                    } else {
                        this.log(TestTypes.SUCCESS, '‚úÖ Memory usage within acceptable limits');
                    }
                } else {
                    this.log(TestTypes.WARNING, '‚ö†Ô∏è Memory API not available in this browser');
                }
            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Memory usage test failed: ${error.message}`);
            }
        }

        async testLargeDataHandling() {
            this.log(TestTypes.INFO, 'üìä Testing large dataset performance...');

            try {
                const startTime = performance.now();

                // Create large dataset
                const largeDataset = [];
                for (let i = 0; i < 1000; i++) {
                    largeDataset.push({
                        id: i,
                        title: `Large Dataset Item ${i}`,
                        description: 'Lorem ipsum '.repeat(20),
                        datetime: new Date(Date.now() + i * 3600000).toISOString()
                    });
                }

                // Test filtering
                const filtered = largeDataset.filter(item => item.id % 10 === 0);

                // Test sorting
                const sorted = [...largeDataset].sort((a, b) => a.title.localeCompare(b.title));

                const endTime = performance.now();
                const processingTime = Math.round(endTime - startTime);

                this.log(TestTypes.INFO, `üìä Processed 1000 items in ${processingTime}ms`);

                if (processingTime > TestConfig.PERFORMANCE_THRESHOLD_MS) {
                    this.addIssue(IssueSeverity.MINOR, 'performance', 'Slow Large Data Processing',
                        `Processing 1000 items took ${processingTime}ms`,
                        'Optimize data processing algorithms');
                } else {
                    this.log(TestTypes.SUCCESS, '‚úÖ Large dataset processing performance acceptable');
                }

            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Large dataset test failed: ${error.message}`);
            }
        }

        async testMemoryLeaks() {
            this.log(TestTypes.INFO, 'üß† Testing for memory leaks...');

            try {
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

                // Create and destroy objects
                for (let cycle = 0; cycle < 10; cycle++) {
                    const objects = [];
                    for (let i = 0; i < 1000; i++) {
                        objects.push({
                            id: i,
                            data: new Array(100).fill('test'),
                            callback: () => console.log('test')
                        });
                    }
                    objects.length = 0;

                    if (window.gc) window.gc();
                    await this.sleep(10);
                }

                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = finalMemory - initialMemory;
                const thresholdBytes = TestConfig.MEMORY_LEAK_THRESHOLD_MB * 1024 * 1024;

                if (memoryIncrease > thresholdBytes) {
                    this.addIssue(IssueSeverity.MAJOR, 'performance', 'Potential Memory Leak',
                        `Memory increased by ${Math.round(memoryIncrease / 1024 / 1024)}MB`,
                        'Investigate memory leaks in object lifecycle management');
                    this.log(TestTypes.WARNING, `‚ö†Ô∏è Memory increased by ${Math.round(memoryIncrease / 1024)}KB`);
                } else {
                    this.log(TestTypes.SUCCESS, '‚úÖ No significant memory leaks detected');
                }

            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Memory leak test failed: ${error.message}`);
            }
        }

        async testConcurrentOperations() {
            this.log(TestTypes.INFO, 'üîÑ Testing concurrent operations...');

            try {
                const startTime = performance.now();
                const promises = [];

                for (let i = 0; i < 10; i++) {
                    promises.push(
                        new Promise(resolve => {
                            setTimeout(() => {
                                const data = { id: i, processed: true };
                                resolve(data);
                            }, Math.random() * 100);
                        })
                    );
                }

                const results = await Promise.all(promises);
                const endTime = performance.now();

                if (results.length === 10) {
                    this.log(TestTypes.SUCCESS, `‚úÖ Concurrent operations completed in ${Math.round(endTime - startTime)}ms`);
                } else {
                    this.log(TestTypes.ERROR, `‚ùå Only ${results.length}/10 concurrent operations completed`);
                }

            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Concurrent operations failed: ${error.message}`);
                this.addIssue(IssueSeverity.MINOR, 'performance', 'Concurrent Operation Issues',
                    'Concurrent operations may have problems',
                    'Implement proper async/await handling and error recovery');
            }
        }

        async testErrorRecovery() {
            this.log(TestTypes.INFO, 'üõ°Ô∏è Testing error recovery...');

            try {
                const errorTests = [
                    () => { throw new Error('Test error'); },
                    () => JSON.parse('invalid json'),
                    () => new Date('invalid date').getTime()
                ];

                let recoveredErrors = 0;

                for (const test of errorTests) {
                    try {
                        test();
                    } catch (error) {
                        recoveredErrors++;
                    }
                }

                this.log(TestTypes.SUCCESS, `‚úÖ Recovered from ${recoveredErrors}/${errorTests.length} test errors`);

            } catch (error) {
                this.log(TestTypes.ERROR, `‚ùå Error recovery test failed: ${error.message}`);
            }
        }

        async runSecurityTests() {
            this.log(TestTypes.INFO, 'üîí Testing security features...');

            // Test XSS prevention
            try {
                const testScript = '<script>alert("xss")</script>';
const div = document.createElement('div');
div.textContent = testScript;

if (div.innerHTML.includes('&lt;script&gt;')) {
this.log(TestTypes.SUCCESS, '‚úÖ XSS prevention working (HTML encoding)');
} else {
this.addIssue(IssueSeverity.CRITICAL, 'security', 'XSS Vulnerability Risk',
'HTML content may not be properly escaped',
'Ensure all user input is properly escaped');
}
} catch (error) {
this.log(TestTypes.ERROR, `‚ùå Security test failed: ${error.message}`);
}

// Test HTTPS usage
if (location.protocol === 'https:') {
this.log(TestTypes.SUCCESS, '‚úÖ HTTPS protocol in use');
} else if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
this.log(TestTypes.INFO, '‚ÑπÔ∏è HTTP acceptable for localhost development');
} else {
this.addIssue(IssueSeverity.MAJOR, 'security', 'Insecure HTTP Protocol',
'Site is not using HTTPS',
'Implement HTTPS for secure data transmission');
}

this.currentTest += 3;
}

async runAccessibilityTests() {
this.log(TestTypes.INFO, '‚ôø Running comprehensive accessibility tests...');

const focusableElements = document.querySelectorAll(
'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
);

if (focusableElements.length > 0) {
this.log(TestTypes.SUCCESS, `‚úÖ Found ${focusableElements.length} keyboard-focusable elements`);
} else {
this.addIssue(IssueSeverity.MAJOR, 'accessibility', 'No Keyboard Navigation',
'No focusable elements found',
'Ensure interactive elements are keyboard accessible');
}

const bodyStyles = getComputedStyle(document.body);
if (bodyStyles.color && bodyStyles.backgroundColor) {
this.log(TestTypes.SUCCESS, '‚úÖ Text and background colors are defined');
} else {
this.addIssue(IssueSeverity.MINOR, 'accessibility', 'Color Definition Missing',
'Text or background colors not explicitly defined',
'Define explicit colors for better accessibility');
}

this.currentTest += 2;
}

// Utility methods
showTestNotification(message, type) {
const notification = document.createElement('div');
notification.style.cssText = `
position: fixed;
top: 20px;
right: 20px;
background: ${this.getNotificationColor(type)};
color: white;
padding: 15px 20px;
border-radius: 8px;
box-shadow: 0 4px 20px rgba(0,0,0,0.3);
z-index: 10000;
max-width: 300px;
transform: translateX(100%);
transition: transform 0.3s ease;
font-family: 'Segoe UI', sans-serif;
`;
notification.textContent = message;

document.body.appendChild(notification);
setTimeout(() => notification.style.transform = 'translateX(0)', 100);

setTimeout(() => {
notification.style.transform = 'translateX(100%)';
setTimeout(() => {
if (notification.parentNode) {
notification.parentNode.removeChild(notification);
}
}, 300);
}, 2000);
}

getNotificationColor(type) {
const colors = {
[TestTypes.SUCCESS]: '#27ae60',
[TestTypes.ERROR]: '#e74c3c',
[TestTypes.WARNING]: '#f39c12',
[TestTypes.INFO]: '#3498db'
};
return colors[type] || colors[TestTypes.INFO];
}

stopTests() {
if (this.abortController) {
this.abortController.abort();
}
this.setRunningState(false);
this.stopTimer();
this.log(TestTypes.WARNING, '‚èπÔ∏è Tests stopped by user');
this.updateProgressText('Tests stopped');
}

clearResults() {
this.testResults = { total: 0, passed: 0, failed: 0, warnings: 0 };
this.issues = [];
this.testLog = [];
this.currentTest = 0;
this.totalTestsToRun = 0;

const logContainer = document.getElementById('logContainer');
if (logContainer) {
logContainer.innerHTML = `
<div class="log-entry log-info">
    Test results cleared. Ready for new tests.
</div>
`;
}

const testResults = document.getElementById('testResults');
if (testResults) {
testResults.innerHTML = `
<p>No tests run yet. Use the buttons above to start testing.</p>
`;
}

const issuesSection = document.getElementById('issuesSection');
if (issuesSection) {
issuesSection.style.display = 'none';
}

const progressFill = document.getElementById('progressFill');
if (progressFill) {
progressFill.style.width = '0%';
}

this.updateProgressText('Ready to start testing');

const testTimer = document.getElementById('testTimer');
if (testTimer) {
testTimer.textContent = '00:00';
}

this.updateSummary();
this.log(TestTypes.INFO, 'üßπ Test environment reset complete');
}

generateFinalReport() {
this.log(TestTypes.INFO, 'üìã Generating final test report...');

const summary = {
timestamp: new Date().toISOString(),
browser: this.browserInfo,
results: this.testResults,
issues: this.issues,
testLog: this.testLog
};

const totalTests = this.testResults.total;
const passedTests = this.testResults.passed;
const overallScore = totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0;

let grade = 'F';
if (overallScore >= 90) grade = 'A';
else if (overallScore >= 80) grade = 'B';
else if (overallScore >= 70) grade = 'C';
else if (overallScore >= 60) grade = 'D';

const resultsDiv = document.getElementById('testResults');
if (resultsDiv) {
resultsDiv.innerHTML = `
<div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; margin-bottom: 20px;">
    <h2 style="color: #2c3e50; margin-bottom: 15px;">üìä Final Test Results</h2>
    <div style="font-size: 3rem; font-weight: bold; color: ${overallScore >= 70 ? '#27ae60' : overallScore >= 50 ? '#f39c12' : '#e74c3c'}; margin-bottom: 10px;">
        ${overallScore}%
    </div>
    <div style="font-size: 1.5rem; color: #666; margin-bottom: 20px;">Grade: ${grade}</div>
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-width: 400px; margin: 0 auto;">
        <div>Total Tests: <strong>${totalTests}</strong></div>
        <div>Passed: <strong style="color: #27ae60;">${passedTests}</strong></div>
        <div>Failed: <strong style="color: #e74c3c;">${this.testResults.failed}</strong></div>
        <div>Warnings: <strong style="color: #f39c12;">${this.testResults.warnings}</strong></div>
    </div>
</div>

<div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
    <h3 style="color: #2c3e50; margin-bottom: 10px;">üìã Test Summary</h3>
    <p><strong>Browser:</strong> ${this.browserInfo.parsed.name} ${this.browserInfo.parsed.version}</p>
    <p><strong>Platform:</strong> ${this.browserInfo.platform}</p>
    <p><strong>Issues Found:</strong> ${this.issues.length}</p>
    <p><strong>Test Duration:</strong> ${document.getElementById('testTimer')?.textContent || '00:00'}</p>
</div>
`;
}

this.finalReport = summary;
this.log(TestTypes.SUCCESS, `‚úÖ Test complete! Score: ${overallScore}% (${grade})`);
}

exportResults(format) {
if (!this.finalReport && this.testResults.total === 0) {
alert('No test results to export. Please run tests first.');
return;
}

const timestamp = new Date().toISOString().split('T')[0];
const filename = `reminders-vault-test-report-${timestamp}`;

if (format === 'json') {
this.exportJSON(filename);
} else if (format === 'html') {
this.exportHTML(filename);
}
}

exportJSON(filename) {
const data = {
report: this.finalReport || {
timestamp: new Date().toISOString(),
results: this.testResults,
issues: this.issues
},
testLog: this.testLog,
browserInfo: this.browserInfo
};

this.downloadFile(`${filename}.json`, JSON.stringify(data, null, 2), 'application/json');
this.log(TestTypes.SUCCESS, '‚úÖ JSON report exported successfully');
}

exportHTML(filename) {
const report = this.finalReport || {};
const overallScore = report.results ?
Math.round((report.results.passed / report.results.total) * 100) : 0;

const criticalIssues = this.issues.filter(issue => issue.severity === IssueSeverity.CRITICAL);
const majorIssues = this.issues.filter(issue => issue.severity === IssueSeverity.MAJOR);
const minorIssues = this.issues.filter(issue => issue.severity === IssueSeverity.MINOR);

const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reminders Vault - Test Report</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f6fa;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .content { padding: 30px; }
        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .summary-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #3498db;
        }
        .summary-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .issues { margin-top: 30px; }
        .issue {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #f39c12;
        }
        .issue.critical {
            background: #f8d7da;
            border-color: #f5c6cb;
            border-left-color: #e74c3c;
        }
        .issue.major {
            background: #fff3cd;
            border-color: #ffeaa7;
            border-left-color: #f39c12;
        }
        .issue.minor {
            background: #d1ecf1;
            border-color: #bee5eb;
            border-left-color: #3498db;
        }
        .timestamp {
            color: #666;
            font-size: 0.9rem;
        }
        .browser-info {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .log-section {
            margin-top: 30px;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        .log-success { background: rgba(39, 174, 96, 0.2); color: #27ae60; }
        .log-error { background: rgba(231, 76, 60, 0.2); color: #e74c3c; }
        .log-warning { background: rgba(243, 156, 18, 0.2); color: #f39c12; }
        .log-info { background: rgba(52, 152, 219, 0.2); color: #3498db; }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üß™ Reminders Vault Test Report</h1>
        <p>Comprehensive Test Results</p>
        <div class="timestamp">Generated: ${new Date().toLocaleString()}</div>
    </div>
    <div class="content">
        <div class="summary">
            <div class="summary-card">
                <div class="summary-number" style="color: ${overallScore >= 70 ? '#27ae60' : overallScore >= 50 ? '#f39c12' : '#e74c3c'}">${overallScore}%</div>
                <div>Overall Score</div>
            </div>
            <div class="summary-card">
                <div class="summary-number">${this.testResults.total}</div>
                <div>Total Tests</div>
            </div>
            <div class="summary-card">
                <div class="summary-number" style="color: #27ae60">${this.testResults.passed}</div>
                <div>Passed</div>
            </div>
            <div class="summary-card">
                <div class="summary-number" style="color: #e74c3c">${this.testResults.failed}</div>
                <div>Failed</div>
            </div>
            <div class="summary-card">
                <div class="summary-number" style="color: #f39c12">${this.testResults.warnings}</div>
                <div>Warnings</div>
            </div>
            <div class="summary-card">
                <div class="summary-number">${this.issues.length}</div>
                <div>Issues Found</div>
            </div>
        </div>

        ${this.issues.length > 0 ? `
        <div class="issues">
            <h2>üö® Issues Found</h2>
            ${criticalIssues.length > 0 ? `
            <h3 style="color: #e74c3c;">Critical Issues (${criticalIssues.length})</h3>
            ${criticalIssues.map(issue => `
            <div class="issue critical">
                <strong>${issue.title}</strong>
                <p>${issue.description}</p>
                ${issue.recommendation ? `<p><strong>Recommendation:</strong> ${issue.recommendation}</p>` : ''}
            </div>
            `).join('')}
            ` : ''}
            ${majorIssues.length > 0 ? `
            <h3 style="color: #f39c12;">Major Issues (${majorIssues.length})</h3>
            ${majorIssues.map(issue => `
            <div class="issue major">
                <strong>${issue.title}</strong>
                <p>${issue.description}</p>
                ${issue.recommendation ? `<p><strong>Recommendation:</strong> ${issue.recommendation}</p>` : ''}
            </div>
            `).join('')}
            ` : ''}
            ${minorIssues.length > 0 ? `
            <h3 style="color: #3498db;">Minor Issues (${minorIssues.length})</h3>
            ${minorIssues.map(issue => `
            <div class="issue minor">
                <strong>${issue.title}</strong>
                <p>${issue.description}</p>
                ${issue.recommendation ? `<p><strong>Recommendation:</strong> ${issue.recommendation}</p>` : ''}
            </div>
            `).join('')}
            ` : ''}
        </div>
        ` : '<div class="issues"><h2>‚úÖ No Issues Found</h2><p>All tests passed without critical issues.</p></div>'}

        <div class="browser-info">
            <h3>üåê Browser Information</h3>
            <p><strong>Browser:</strong> ${this.browserInfo.parsed.name} ${this.browserInfo.parsed.version}</p>
            <p><strong>Platform:</strong> ${this.browserInfo.platform}</p>
            <p><strong>Language:</strong> ${this.browserInfo.language}</p>
            <p><strong>Cookies Enabled:</strong> ${this.browserInfo.cookieEnabled}</p>
            <p><strong>Online:</strong> ${this.browserInfo.onLine}</p>
        </div>

        <div class="log-section">
            <h3>üìã Test Log</h3>
            ${this.testLog.slice(-50).map(entry => `
            <div class="log-entry log-${entry.type}">
                [${new Date(entry.timestamp).toLocaleTimeString()}] ${entry.message}
            </div>
            `).join('')}
        </div>
    </div>
</div>
</body>
</html>`;

this.downloadFile(`${filename}.html`, html, 'text/html');
this.log(TestTypes.SUCCESS, '‚úÖ HTML report exported successfully');
}

downloadFile(filename, content, mimeType) {
try {
const blob = new Blob([content], { type: mimeType });
const url = URL.createObjectURL(blob);
const link = document.createElement('a');
link.href = url;
link.download = filename;
link.style.display = 'none';

document.body.appendChild(link);
link.click();
document.body.removeChild(link);

setTimeout(() => URL.revokeObjectURL(url), 1000);
} catch (error) {
this.log(TestTypes.ERROR, `‚ùå File download failed: ${error.message}`);
alert(`Failed to download file: ${error.message}`);
}
}
}

// Initialize test runner when DOM is loaded
let testRunner;

function initializeTestRunner() {
try {
testRunner = new ReminderVaultTestRunner();

// Auto-run quick tests after 2 seconds if no tests are running
setTimeout(() => {
if (testRunner && !testRunner.isRunning) {
testRunner.log(TestTypes.INFO, 'üéØ Auto-running quick compatibility check...');
testRunner.runQuickTests().catch(error => {
console.error('Auto-run quick tests failed:', error);
});
}
}, 2000);
} catch (error) {
console.error('Failed to initialize test runner:', error);
alert('Failed to initialize test runner. Please refresh the page.');
}
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', initializeTestRunner);
} else {
initializeTestRunner();
}

// Global error handlers
window.addEventListener('error', (event) => {
if (testRunner) {
testRunner.log(TestTypes.ERROR, `üö® Uncaught error: ${event.error?.message || event.message}`);
testRunner.addIssue(IssueSeverity.CRITICAL, 'system', 'Uncaught JavaScript Error',
event.error?.message || event.message,
'Fix JavaScript errors to ensure proper functionality');
}
console.error('Global error:', event.error || event.message);
});

window.addEventListener('unhandledrejection', (event) => {
if (testRunner) {
testRunner.log(TestTypes.ERROR, `üö® Unhandled promise rejection: ${event.reason}`);
testRunner.addIssue(IssueSeverity.MAJOR, 'system', 'Unhandled Promise Rejection',
event.reason?.toString() || 'Promise rejection not caught',
'Add proper error handling for all promises');
}
console.error('Unhandled promise rejection:', event.reason);
});

// Handle page unload during tests
window.addEventListener('beforeunload', (e) => {
if (testRunner && testRunner.isRunning) {
e.preventDefault();
e.returnValue = 'Tests are currently running. Are you sure you want to leave?';
return e.returnValue;
}
});

// Expose testRunner for debugging (only in development)
if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
window.testRunner = testRunner;
}
</script>
</body>
</html>